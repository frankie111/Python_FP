from datetime import datetime, timedelta
from functools import reduce

from lab5.models.CookedDish import CookedDish
from lab5.models.Identifiable import Identifiable


class Order(Identifiable):
    def __init__(self, id_=None, customer_id: int = None, item_ids=None, total_price: int = None,
                 time_stamp: str = None):
        super().__init__(id_)
        self.__customer_id = customer_id
        self.__item_ids = item_ids
        self.__total_price = total_price
        self.__time_stamp = time_stamp

    def __eq__(self, other):
        return self.__customer_id == other.__customer_id and self.__item_ids == other.__item_ids

    def __str__(self):
        return super().__str__() + f", Kunden-ID = '{self.__customer_id}', Artikel = '{self.__item_ids}', Gesamtkosten = '{self.__total_price}'"

    def __hash__(self):
        return hash(self.__str__())

    @property
    def customer_id(self):
        return self.__customer_id

    @customer_id.setter
    def customer_id(self, customer_id):
        self.__customer_id = customer_id

    @property
    def item_ids(self):
        return self.__item_ids

    @item_ids.setter
    def item_ids(self, item_ids):
        self.__item_ids = item_ids

    @property
    def total_price(self):
        return self.__total_price

    @total_price.setter
    def total_price(self, total_price):
        self.__total_price = total_price

    @property
    def time_stamp(self):
        return self.__time_stamp

    @time_stamp.setter
    def time_stamp(self, time_stamp):
        self.__time_stamp = time_stamp

    def create_time_stamp(self):
        """
        Method for creating the timestamp of this Order (as a string in iso format)
        """
        self.__time_stamp = datetime.now().isoformat()

    def compute_etd(self, dishes: list[CookedDish]):
        """
        Returns the estimated time of delivery for the current order
        :param dishes: The list of cooked dishes present in this order, as drinks don't have a prep_time
        """
        max_prep_time = max(dishes, key=lambda dish: dish.prep_time).prep_time
        etd = datetime.fromisoformat(self.__time_stamp) + timedelta(minutes=int(max_prep_time))
        return etd.isoformat()

    def compute_total_price(self, items):
        """
        Adds up the prices from the items list
        :returns: Total order price
        """
        # items[0] = items[0].id
        self.__total_price = reduce(lambda a, m: a + int(m.price), items, 0)
        return self.__total_price

    def generate_bill(self, items):
        """
        Generates and returns a bill, containing the items of this order
        :returns: The bill as a string
        """
        self.compute_total_price(items)
        bill_lines = list(map(lambda item: f"{item.name} " + "." * (30 - len(item.name)) + f" {item.price}", items))
        bill_lines.append(f"\nGesamtkosten " + '.' * 18 + f" {self.__total_price}")

        dishes = []
        for it in items:
            if type(it) == CookedDish:
                dishes.append(it)

        time = datetime.fromisoformat(self.__time_stamp).strftime(" %R ")
        etd = datetime.fromisoformat(self.compute_etd(dishes)).strftime(" %R ")
        bill_lines.append(f"\nUhrzeit der Bestellung: {time}")
        bill_lines.append(f"Voraussichtliche Lieferzeit: {etd}")

        return reduce(lambda a, b: a + '\n' + b, bill_lines)

    def print_bill(self, items):
        """
        Prints the bill of this order generated by the __generate_bill method
        """
        print(self.generate_bill(items))

    def pprint(self, customer, items):
        """
        Returns a string for pretty printing an order
        :param customer: The customer on this order
        :param items: A list of items contained in this order
        """
        return f"Bestellung {self.id} f√ºr {customer.name} - Adresse: {customer.address}:\n" + self.generate_bill(
            items)
